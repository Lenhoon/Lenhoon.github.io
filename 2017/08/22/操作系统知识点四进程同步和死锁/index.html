<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Lenhoon">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Lenhoon">
    
    <meta name="keywords" content="iOS开发者,网络安全,全栈开发">
    
    <meta name="description" content="">
    <meta name="description" content="本笔记是参照《2014年操作系统联考复习指导-王道考研系列》一书，整理而来，只列出知识点。个人观点，认为搭配《计算机组成原理》来看效果更加。时隔4年，又拿起这本书，感谢王道，感谢王道论，感谢那段时光，不忘初心。  #一进程同步几个概念  引进进程是为了协调进程之间的相互制约关系  临界资源：一次仅允许一个进程使用的资源。（物理设备如打印机、变量和数据） 注意与共享资源的区别：一段时间内能否被多个">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统知识点四进程同步和死锁">
<meta property="og:url" content="https://lenhoon.github.io/2017/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E6%AD%BB%E9%94%81/index.html">
<meta property="og:site_name" content="零号空间">
<meta property="og:description" content="本笔记是参照《2014年操作系统联考复习指导-王道考研系列》一书，整理而来，只列出知识点。个人观点，认为搭配《计算机组成原理》来看效果更加。时隔4年，又拿起这本书，感谢王道，感谢王道论，感谢那段时光，不忘初心。  #一进程同步几个概念  引进进程是为了协调进程之间的相互制约关系  临界资源：一次仅允许一个进程使用的资源。（物理设备如打印机、变量和数据） 注意与共享资源的区别：一段时间内能否被多个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tKfTcgy1fisltkup68j30bs08lq38.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcgy1fisluntxs4j30a604oq31.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tKfTcgy1fislv5vcv9j30cx0bbdg7.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tKfTcgy1fislvyke2gj30qr0k2wfw.jpg">
<meta property="article:published_time" content="2017-08-22T08:55:25.000Z">
<meta property="article:modified_time" content="2017-08-22T11:21:22.000Z">
<meta property="article:author" content="Lenhoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ws2.sinaimg.cn/large/006tKfTcgy1fisltkup68j30bs08lq38.jpg">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>操作系统知识点四进程同步和死锁 · 零号空间 | lenhoon&#39;s Blog | 0&#39;Space</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/Lenhoon.github.io/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/Lenhoon.github.io/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/Lenhoon.github.io/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/Lenhoon.github.io/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/Lenhoon.github.io/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/Lenhoon.github.io/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 4.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/Lenhoon.github.io/" >0&#39;s Space</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">操作系统知识点四进程同步和死锁</a>
            </div>
    </div>
    
    <a class="home-link" href=/Lenhoon.github.io/>0's Space</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/Lenhoon.github.io/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            操作系统知识点四进程同步和死锁
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">6.4k</span>阅读时长: <span class="post-count reading-time">24 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2017/08/22</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/Lenhoon.github.io/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/Lenhoon.github.io/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p>本笔记是参照《2014年操作系统联考复习指导-王道考研系列》一书，整理而来，只列出知识点。个人观点，认为搭配《计算机组成原理》来看效果更加。<br>时隔4年，又拿起这本书，感谢王道，感谢王道论，感谢那段时光，不忘初心。</p>
</blockquote>
<p>#一进程同步几个概念</p>
<ol>
<li><p>引进进程是为了协调进程之间的相互制约关系</p>
</li>
<li><p>临界资源：一次仅允许一个进程使用的资源。（物理设备如打印机、变量和数据）<br> <strong>注意与共享资源的区别</strong>：一段时间内能否被多个进程访问，磁盘设备就是可以，所以是共享资源</p>
</li>
<li><p>临界区：访问临界资源时，把访问临界资源的<strong>那段代码</strong>称为<strong>临界区</strong>，为保证临界资源的正确的正确使用，把临界资源的访问过程分为四个阶段：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	entry section;        &#x2F;&#x2F;进入区  ①检查是否可以进入临界区②设置正在访问临界区标志</span><br><span class="line">	critical section;     &#x2F;&#x2F;临界区</span><br><span class="line">	exit section;     &#x2F;&#x2F;退出区  ①将正在访问标志清除</span><br><span class="line">	remainder section;    &#x2F;&#x2F;剩余区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ①进入区：在进入区要检查是否可以进入临界区，如果可以则应设置争取的临界区的标志，以防止其他进程同时进入临界区。<br> ②临界区：进程中访问临界资源的那段代码，又称<strong>临界段</strong>。<br> ③退出区：将正在访问临界区的标志清除。<br> ④剩余区：代码中的其余部分。</p>
</li>
<li><p><strong>同步</strong>和<strong>互斥</strong><br> 就是每次只能有一个进程执行或者说是多个进程需要等待，同步是因为顺序原因而等待，互斥是因为独占资源，一个临界资源一次只允许一个访问，所以会有其他的进程等待<br> ①同步（直接制约关系）：为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调他们的工作次序</strong>而<strong>等待</strong>、<strong>传递信息所产生的制约关系</strong>，这种直接制约关系源于他们之间的合作。<br> 例如：输入进程A通过但缓存想进程B提供数据，当该缓存区空时，进程B不能获得所需数据而阻塞，一段进程A数据送入缓冲区，进程B被唤醒，反之，当缓冲区满是进程A被阻塞。<br> <em>个人理解</em>：就是一个前后关系顺序，后面的完成需要前面的工作完成，前面的工作完成需要后面腾出空间来，有点像图里面网的概念（AOV，AOE）但又不一样。<br> ②互斥（间接制约关系）：当一个进程进入临界区使用临界资源时，另一个进程必需等待。如打印进打印，注意这里得到资源后不是立刻运行，而是进入就绪队列，等待调用。<br> <em>个人理解</em>：不是因为顺序原因，而是因为独占资源而一个进程需要等待</p>
</li>
<li><p>为禁止两个进程同时进入临界区，同步机制需满足以下准则：<br> ①空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区<br> ②忙着等待：当有进程进入临界区时，其他进入临界区的进程必需等待<br> ③有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（不能等太久了）<br> ④让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等（比如高响应比优先调度算法）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P0 进程</span><br><span class="line">while(turn !&#x3D;0);      </span><br><span class="line">cirtical section;</span><br><span class="line">turn &#x3D; 1;</span><br><span class="line">emainder section;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>#二 实现临界区互斥的基本方法（设置标志）</p>
<ol>
<li><p>软件实现方法：在进入区设置和检查一些标志来表明是否有进程在临界区，有进程进入，则通过<strong>循环检查</strong>进行等待<br> ①单标志法：设置一个共用变量turn，用于指示被允许进去的进程的编号，若turn=0，则允许P0进入</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P0 进程                       P1进程                    </span><br><span class="line">while(turn !&#x3D;0);             while(turn !&#x3D;0);             &#x2F;&#x2F;进入区</span><br><span class="line">cirtical section;            cirtical section;             &#x2F;&#x2F;临界区</span><br><span class="line">turn &#x3D; 1;                     turn &#x3D; 0;                       &#x2F;&#x2F;退出区</span><br><span class="line">remainder section;           remainder section;       &#x2F;&#x2F;剩余区</span><br></pre></td></tr></table></figure>

<p> 这种方法可以<strong>确保每次只进入一个进程</strong>，但是<strong>两个进程必需交替的进入临界区</strong>，**<br> 如果一个进程不再进入临界区了，那么另一个进程也将无法进入临界区（违背“空闲让进”）<strong>，这样容易造成资</strong>源利用不充分**。<br> 造成这种现象的原因是因为退出区turn每次设置成被允许进去的进程的编号<br> ②双标志法先检查：在每一个进程访问临界区资源之前，先查看一下临界区资源是否正被访问，若正被访问，该进程需要等待，否则，进程进入自己的临界区，设一个一个数据结构flag[i]，如果第i个元素值为FLASE,标示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pi 进程                       Pj进程                    </span><br><span class="line">while(flag[j]);   ①             while(flag[i]);         ②             &#x2F;&#x2F;进入区</span><br><span class="line">flag[i] &#x3D; true;   ③             flag[j] &#x3D; true;         ④          &#x2F;&#x2F;进入区</span><br><span class="line">cirtical section;              cirtical section;               &#x2F;&#x2F;临界区        </span><br><span class="line">flag[i] &#x3D; false;                 flag[j] &#x3D; false;                   &#x2F;&#x2F;退出区   </span><br><span class="line">remainder section;         remainder section;         &#x2F;&#x2F;剩余区</span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>优点：不用交替进入，可连续使用
缺点：Pi和Pj能同时进入临界区（按照①②③④的顺序）违背忙着等待，即在检查对方flag之后进入临界区切换自己的flag之前有段时间，这时，flag[j]为flase,但是到执行flag[i]=true这段之间有时间，这段时间flag[i]还是flase，这样就使得步骤②也进入，结果都检查通过，说明**检查和修改操作不能一次进行**，没有保证原子操作
③双标志发后检查：先检查是先检查对方进程状态，再置自己的标志，由于在检查和放置中中间这段时间可插入另一个进程到达时的检测操作，或造成两个进程分别检查后同时进入临界区。后检查法，先设置自己的标志位true,在检查对方的状态，若对方为true，则等待，否则进入

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pi 进程                       Pj进程                     </span><br><span class="line">flag[i] &#x3D; ture;                 flag[j] &#x3D;  ture;                  &#x2F;&#x2F;进入区</span><br><span class="line">while(flag[j]);                while(flag[i]);                      &#x2F;&#x2F;进入区</span><br><span class="line">cirtical section;              cirtical section;               &#x2F;&#x2F;临界区        </span><br><span class="line">flag[i] &#x3D; false;                 flag[j] &#x3D; false;                   &#x2F;&#x2F;退出区   </span><br><span class="line">remainder section;         remainder section;         &#x2F;&#x2F;剩余区</span><br></pre></td></tr></table></figure>

很明显，这种方法容易设置成两个true,情景如上，造成死锁现象
④Perterson’s Algorithm：为防止两个进程进入临界区而无限等待，又设置**turn变量，表示不允许进入临界区的进程编号**，每个进程先设置自己的标志后在设置**turn标志，不允许另一个进程进入**（这里其实就是**使用&amp;&amp;模拟一个原子操作**），再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当两个进程同时要求进入时，只进入一个</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pi 进程                            Pj进程                     </span><br><span class="line">flag[i] &#x3D; ture;turn &#x3D;j;         flag[j] &#x3D;  ture;turn &#x3D; i;                  &#x2F;&#x2F;进入区</span><br><span class="line">while(flag[j]&amp;&amp;turn&#x3D;&#x3D;j]);     while(flag[i]&amp;&amp;turn&#x3D;&#x3D;i);                      &#x2F;&#x2F;进入区</span><br><span class="line">cirtical section;                cirtical section;               &#x2F;&#x2F;临界区        </span><br><span class="line">flag[i] &#x3D; false;                   flag[j] &#x3D; false;                   &#x2F;&#x2F;退出区   </span><br><span class="line">remainder section;           remainder section;         &#x2F;&#x2F;剩余区</span><br><span class="line">flag[i] &#x3D; ture;turn &#x3D;j保证判断语句的两个条件不同时为真</span><br></pre></td></tr></table></figure>

<pre><code>本算法利用flag解决互斥访问，利用turn解决死锁</code></pre><ol start="2">
<li><p>硬件实现方法：计算机提供了<strong>特殊的硬件指令</strong>，允许对一个字中的内容进行检测和修正，或者对两个字的内容进行交换，通过支持实现临界段问题的低级方法称为<strong>元方法</strong><br> ①中断屏蔽方法：禁止一切中断的放生，屏蔽中断、关中断，因为CPU只在发生中断时引起进程切换，这样保证临界区的代码顺利执行完<br> 关中断-&gt;临界区-&gt;开中断<br> 缺点：限制处理机的交替执行程序的能力，执行效率降低，同时，将关中断的权利交给用户很不明智<br> ②硬件指令方法：<br> <strong>TestAndSet</strong>指令原子操作，执行该代码是不允许被中断，其功能是读出指定标志后把该标志设置为真，指令功能描述如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean TestAndSet(boolean *lock)&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old &#x3D; *lock;</span><br><span class="line">    *lock &#x3D; true;</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以为每个临界资源设置一个共享布尔变量block，true标示正在被占用，处置为flase，访问之前利用TestAndSet检查并修改，若有进程在，则重复检查<br> while TestAndSet(&amp;lock);<br> 进程的临界区代码段;<br> lock = false;<br> 进程的其他代码;<br> <strong>Swap指令</strong>：该指令的功能是交换两个字（字节）的内容，功能描述如下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Swap(boolean *a,boolean *b)&#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp &#x3D; *a;</span><br><span class="line">    *a &#x3D; *b;</span><br><span class="line">    *b &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的实现不是由软件实现定义，他们是由硬件逻辑直接实现，不会被中断<br> 为每个临界资源设置一个<strong>共享布尔变量lock</strong>，初值为false，在设置一个<strong>局部布尔变量key</strong>，用于与lock交换信息。<strong>进入临界区之前利用Swap指令交换lock与key的内容</strong>，然后<strong>检查key的状态</strong>；有进程在临界区时，重复检查和交换，直到进程退出，利用Swap指令实现进程互斥算法描述如下:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; true; </span><br><span class="line">while(key !&#x3D; flase) &#x2F;&#x2F;key为false时不在交换进入临界区，也就是说lock要为flase</span><br><span class="line">    Swap(&amp;lock,&amp;key);</span><br><span class="line"> 进程的临界区代码;</span><br><span class="line">lock &#x3D; false;</span><br></pre></td></tr></table></figure>

<p> 进程进入其他代码;<br> 硬件方法<br> 优点：适用于任意数目的进程，不管是单处理机还是多处理机，可以支持进程内的多个临界区，只需为每个临界区设立一个布尔变量<br> 缺点：进程等待进入临界区时可能耗费处理机时间，不能实现让权等待，有的进程可能一直选不上，就导致饥饿现象（饥饿是一个进不去，死锁是两个多进程的状态同时一样）</p>
</li>
</ol>
<p>#三 信号量（互斥型和资源型）<br>    信号量机制一种功能较强的机制，可用来解决互斥和同步问题，能被两个各个原语<strong>wait(S)-P操作</strong>和<strong>signal(S)-V</strong>操作来访问，由硬件完成</p>
<ol>
<li><p><strong>整型信号量</strong>：被定义为一个用于表示资源数目的整型量S，wait和signal的操作可描述为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**wait**(S)&#123;</span><br><span class="line">    while(S&lt;&#x3D;0);</span><br><span class="line">    S &#x3D; S-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**signal**(S)&#123;</span><br><span class="line">    S &#x3D; S+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> wait操作中只要S&lt;=0就要等待，该机制未遵循让权等待，而是使进程忙等</p>
</li>
<li><p>记录型信号量：不存在忙等现象的进程同步机制，除了需要一个用于<strong>资源数目的整形资源value</strong>外，在增加一个进程链表L,用于链接所有等待该进程的资源，记录型信号量是由于采用了记录型的数据结构而得名，记录型数据结构可描述为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct process *L;</span><br><span class="line">&#125;semaphpre;</span><br><span class="line">相应的wait(S)和signal(S)操作如下</span><br><span class="line">void wait(semaphore s)&#123;</span><br><span class="line">    S.value — ;</span><br><span class="line">    if(S.value&lt;0)&#123;</span><br><span class="line">        add this process to S.L;</span><br><span class="line">        block(S.L);    &#x2F;&#x2F;调用block原语，进行自我阻塞，放弃处理插入阻塞队列</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 该操作S.value—，表示进程请求一个该类资源，当S.value&lt;0时，表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，这遵循了“让权等待”的准则</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void signal(semaphore S)&#123; &#x2F;&#x2F;相当于释放资源</span><br><span class="line">    S.value ++;</span><br><span class="line">    if(S.value&lt;&#x3D;0)&#123;</span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> signal操作表示释放一个资源，使系统中可供分配的该类资源数增1，若加1后仍然是S.value&lt;=0（这里必然会多一个资源，但是S.value还是小于等于0，说明等待队列还有进程），则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L中的第一个等待进程唤醒</p>
</li>
<li><p>利用信号量实现同步，执行的先后顺序<br> 设S为实现进程P1和P2同步的公共信号量，初值为0，进程P2中的语句y要使用进程P1中的语句x运行结果，所以只有当语句x执行完成之后语句y才可以执行。算法如下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore S&#x3D;0;    &#x2F;&#x2F;初始化信号量</span><br><span class="line">P1()&#123;</span><br><span class="line">    …</span><br><span class="line">    x;                      &#x2F;&#x2F;语句x</span><br><span class="line">    V(S);                 &#x2F;&#x2F;告诉进程P2，语句x已经完成</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">    …</span><br><span class="line">    P(S);                 &#x2F;&#x2F;检查语句x是否可以运行完成</span><br><span class="line">     y;                      &#x2F;&#x2F;检查无误，运行y语句</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里先将信号量设置为0，然后先执行V操作+1，P操作之前要先检查，所以在运行代码之前</p>
</li>
<li><p>利用信号量实现进程互斥<br> 这里S信号量的传值为1，，P1、P2为互斥的信号量，由于S为1，所以只需把S至于P(S)和P(V)之间，即可实现两进程对临界资源的互斥访问</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S&#x3D;1;           &#x2F;&#x2F;初始化信号量</span><br><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);                        &#x2F;&#x2F;准备开始访问临界资源，加锁</span><br><span class="line">    进入P1的临界区</span><br><span class="line">    V(S);                       &#x2F;&#x2F;访问结束，解锁</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);                        &#x2F;&#x2F;准备开始访问临界资源，加锁</span><br><span class="line">    进入P2的临界区</span><br><span class="line">    V(S);                       &#x2F;&#x2F;访问结束，解锁</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 互斥的实现是不同进程对同一信号量进行P、V操作<br> 小结：同步是信号量为0，先V后P，让后面的不能执行，PV在不同的进程中，互斥是信号量为1，先P后V，在同一个进程中</p>
</li>
<li><p>利用信号量实现前驱关系<br> 信号量也可以用来描述程序之间的前驱关系，如下图S1,S2,S3,S4,…,S6是最简单的程序段（只有一条语句），为使各程序能正确执行，应设置若干<strong>初始值为0信号量</strong>，为保证S1-&gt;S2、S1-&gt;S3,应分别设置信号量a1,a2,同样，为了保证S2-&gt;S4、S2-&gt;S5、S3-&gt;S6、S4-&gt;S6、S5-&gt;S6，应设置信号量b1、b2、c、d、e.<br> <img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fisltkup68j30bs08lq38.jpg" alt="信号量前驱关系图)"><br> 算法如下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore a1&#x3D;a2&#x3D;b1&#x3D;b2&#x3D;c&#x3D;d&#x3D;e&#x3D;0;     &#x2F;&#x2F;初始化信号量</span><br><span class="line">S1()&#123;</span><br><span class="line">    …;</span><br><span class="line">    V(a1);V(a2);         &#x2F;&#x2F;S1已经运行完</span><br><span class="line">&#125;</span><br><span class="line">S2()&#123;</span><br><span class="line">    P(a2);                 &#x2F;&#x2F;检查S1是否运行完成</span><br><span class="line">    …;</span><br><span class="line">    V(b1);V(b2);         &#x2F;&#x2F;S2已经运行完</span><br><span class="line">&#125;</span><br><span class="line">S3()&#123;</span><br><span class="line">    P(a2);                 &#x2F;&#x2F;检查S1是否运行完成</span><br><span class="line">    …;</span><br><span class="line">    V(c);                  &#x2F;&#x2F;S3已经运行完</span><br><span class="line">&#125;</span><br><span class="line">S4()&#123;</span><br><span class="line">    P(b1);                &#x2F;&#x2F;检查S2是否运行完成</span><br><span class="line">    …;</span><br><span class="line">    V(d);                 &#x2F;&#x2F;S4已经运行完</span><br><span class="line">&#125;</span><br><span class="line">S5()&#123;</span><br><span class="line">    P(b2);                &#x2F;&#x2F;检查S2是否运行完成</span><br><span class="line">    …;</span><br><span class="line">    V(e);                &#x2F;&#x2F;S5已经运行完</span><br><span class="line">&#125;</span><br><span class="line">S(6)&#123;</span><br><span class="line">    P(c);                &#x2F;&#x2F;检查S3是否运行完成</span><br><span class="line">    P(d);                &#x2F;&#x2F;检查S4是否运行完成</span><br><span class="line">    P(e);                &#x2F;&#x2F;检查S5是否运行完成</span><br><span class="line">    …;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析进程同步和互斥问题的方法步骤<br> ①关系分析：找出进程数；分析是同步还是互斥<br> ②整理思路：根据进程的操作流程确认P、V操作的大致顺序<br> ③设置信号量：设置需要的信号量，设置初值</p>
</li>
</ol>
<p>#四 经典同步问题</p>
<ol>
<li><p>生产者-消费者问题<br> ①问题描述：一组生产者和一组消费者进程<strong>共享一个初始为空，大小为n的缓冲区</strong>，只有<strong>缓冲区没满时，生产者才能把消息放入到缓冲区</strong>，否则必须等待；只有<strong>缓冲区不空时消费者才能从中去取出消息</strong>，否则必需等待。由于<strong>缓冲区是临界资源</strong>，只允许生产者放入消息或一个消费者从中取出消息。<br> ②问题分析：按照三步走的方法首先关系分析：两个进程，是同步操作，同时对缓冲区的操作是互斥的；整理思路，需要解决的是互斥和同步PV操作的位置；信号量设定，设置<strong>mutexw为互斥信号量初值为1</strong>，<strong>信号量full</strong>用于记录当前缓冲池中<strong>满缓冲区数</strong>，<strong>初值为0</strong>，<strong>信号量empty</strong>记录当前缓冲池<strong>空缓冲区数</strong>，<strong>初值为n</strong><br> ③代码如下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex&#x3D;1;</span><br><span class="line">semaphore empty&#x3D;n;</span><br><span class="line">semaphpre full&#x3D;0;</span><br><span class="line">producer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        produce an item in nextp;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        add nextp to buffer;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);</span><br><span class="line">        P(mutex);</span><br><span class="line">        remove an item from buffer;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意：对empty和full变量的操作必需放在对mutex的P操作之前；如果不的话，试想，先执行P(mutex)在执行P(empty)，消费者先P(mutex)然后执行P(full)，这样是不行的，如果生产者已经缓存区放满消费者没有取，此时empty=0，当下次仍然是消费者进程，先执行P(mutex)封锁信号量，在执行P(empty)将被阻塞，希望消费者使用V(empty)释放，但是此时被锁住，消费这是不能执行的，就出现了死锁；另外使用empty和两个信号量的原始是因为对缓冲器是执行两种操作，两种制约关系，不是有了才能取，而是空不能取，满不能放，所以需要两种。</p>
</li>
<li><p>更复杂的一个生产-消费者问题<br> ①问题描述：桌子上一只盘子，每次只能放一个水果，爸爸只放苹果，妈妈只放橘子，儿子专吃橘子，女儿专吃苹果，只有盘子为空就能放，盘中有水果才能吃<br> <img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fisluntxs4j30a604oq31.jpg" alt="更复杂的一个生产-消费者问题"><br> ②问题分析：四个进程，爸爸和女儿，妈妈和儿子是同步关系，每次只能放一个水果，所以爸爸和妈妈是互斥关系；这里可以抽象为4个进程，两个生产者，两个消费者被连接到大小为1的缓冲器<br> 信号量设置：设置互斥信号量plate，初值为1，表示允许放入，且只允许放入一个，apple为盘中是否有苹果，初值为0，orange表示橘子<br> 代码如下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate&#x3D;1,apple&#x3D;0;orange&#x3D;0;</span><br><span class="line">dad()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        prepare an apple;</span><br><span class="line">        P(plate);</span><br><span class="line">        put the apple on the plate;</span><br><span class="line">        V(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        prepare an orange;</span><br><span class="line">        P(plate);</span><br><span class="line">        put the apple on the plate;</span><br><span class="line">        V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(orange);</span><br><span class="line">        take an orange on the plate;</span><br><span class="line">        V(plate);</span><br><span class="line">        eat the orange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(apple);</span><br><span class="line">        take an apple from the plate;</span><br><span class="line">        V(plate);</span><br><span class="line">        eat the apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>读者写着问题<br> ①问题描述：有读者和写着两个并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据是不会产生副作用，当某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误，因此要求是A允许多个读者可以同时对文件执行读操作B只允许一个写者往文件中写信息C任一写者在完成写操作之前允许其他读者或写着工作④写者执行写操作前，应让读者和写者完全退出<br> ②问题分析：两个进程，读者和写者，写着比较简单，用一对PV操作就可以解决，读者问题比较复杂，必须实现与写者的互斥，还有实现与其他读者的同步，这里用到一个计数器，来判断是否有读者读文件，有读者的时候，写者无法写文件，此时会一直占用文件，不同读者对计数器的访问也是互斥的；信号量的设置，首先设置count计数器，用来记录当前读者数量，初值为0，设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保护读者和写着的互斥访问；增加P(w)用于实现写优先P80</p>
</li>
<li><p>哲学家进餐问题<br> ①5名哲学家，五只筷子，中间一碗米饭，只有当哲学家饥饿的时候才试图拿起左右两根筷子，如果筷子已在他人手上，则需等待,只有拿到两根筷子才能进餐，进餐完毕放下筷子继续思考<br> <img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fislv5vcv9j30cx0bbdg7.jpg" alt="哲学家进餐问题图">s<br> ②代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] &#x3D; &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex&#x3D;1;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    do&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(choostick[i]);</span><br><span class="line">        think;</span><br><span class="line">    &#125;while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意：这里是使用的do while，只有取筷子的时候上锁了，放筷子的时候没有，另外注意一双筷子的标示方法 i ,(i+1)%5</p>
</li>
<li><p>吸烟者问题<br> ①问题描述:一个系统有三个抽烟者和一个供应进程（多个消费者，一个生产者生产不同物品），抽烟者使用烟草、纸和胶水不停的卷烟，并且抽调，三个抽烟者第一个拥有烟草，第二个拥有纸，第三个拥有胶水，供应者无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉，并给供应者一个信号告诉完成了，供应者就会放另外两种材料放在桌子上，这种过程一直重复（让三个吸烟者轮流抽烟）<br> ②问题分析：三个抽烟者与供应者是同步关系，供应者无法同时满足两个以上抽烟者，所以三个抽烟者动作互斥，四个进程（三个抽烟者、一个供应者），信号量offer1，offer2，offer3分别表示烟草和纸、烟草和胶水、纸和胶水的组合，信号量finish用与互斥进行抽烟动作<br> 代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int random;</span><br><span class="line">semaphore offer1 &#x3D; 0;</span><br><span class="line">semaphore offer2 &#x3D; 0;</span><br><span class="line">semaphore offer3 &#x3D; 0;</span><br><span class="line">semaphore finish &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;供应者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    random &#x3D; 任意一个随机整数；</span><br><span class="line">    random &#x3D; random%3;</span><br><span class="line">    if(random&#x3D;&#x3D;0)</span><br><span class="line">        V(offer1);</span><br><span class="line">    else if(random&#x3D;&#x3D;1)</span><br><span class="line">        V(offer2);</span><br><span class="line">    else</span><br><span class="line">        V(offer3);</span><br><span class="line">    任意两种材料当到桌子上；</span><br><span class="line">    P(finish); &#x2F;&#x2F; 已经完成</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拥有烟草者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    P(offer3);</span><br><span class="line">    拿纸和胶水，卷成烟，抽调；</span><br><span class="line">    V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拥有烟纸</span><br><span class="line">while(1)&#123;</span><br><span class="line">    P(offer2);</span><br><span class="line">    拿烟草和胶水，卷成烟，抽调；</span><br><span class="line">    V(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拥有烟草者</span><br><span class="line">while(1)&#123;</span><br><span class="line">    P(offer1);</span><br><span class="line">    拿烟草和纸，卷成烟，抽调；</span><br><span class="line">    V(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>#五 死锁</p>
<ol>
<li>定义：是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。<br> 例子：一个窄桥，两辆车；</li>
<li>死锁产生的原因<br> ①系统资源的竞争（空间上）：争夺<strong>不可剥夺资源</strong>，还不释放自己使用的资源，产生了死锁；对可剥夺资源的竞争不会产生死锁<br> ②进程推进顺序的非法（时间上）：请求和释放资源的顺序不当，同样会导致死锁P1、P2保持R1、R2与此同时P1又去申请R2,P2申请R1导致了死锁；信号量使用的顺序不当，也同样会导致死锁，进程间彼此等待对方发来消息（A等B，B等A）<br> ③死锁产生的必要条件，死锁产生必须满足下面四个条件，其中任一条件不满足，死锁就不会发生<br> 互斥条件：在一段时间内某资源仅为一个进程所占用，此时若有其他进程请求该资源，则请求进程只能等待<br> 不剥夺条件：只能主动释放<br> 请求和保持条件：保持至少一个资源，同时又提出了新的资源请求，而该资源被其他资源占用，此时请求进程被阻塞，但对自己已获得的资源保持不放<br> 循环等待条件：存在一种进程资源的循环等待链，已获得资源同时被链中的下一个进程所请求。如下图所示<br> <img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fislvyke2gj30qr0k2wfw.jpg" alt="循环等待条件示意图"><br> 注：循环等待只是死锁的必要条件，循环等待不一定产生死锁，若资源数为1，则一定产生死锁，</li>
<li>死锁的处理策略<br> ①预防死锁：破坏四个条件<br> ②避免死锁：资源动态分配中用某种方法防止系统进入不安全状态，从而避免死锁<br> ③死锁的检测及解除：允许在运行过程中发生死锁，通过系统的检测机构及时地检测出死锁的发生，然后采取措施解除死锁。</li>
<li>银行家算法-死锁避免算法</li>
<li>死锁的检测：资源分配图</li>
<li>死锁的解除：①资源剥夺法；②撤销进程法（撤销部分或者全部死锁进程）；③进程回退法，让一个进程回退到足以避免死锁的地步，进程回退时自愿释放资源而不是剥夺，这要求系统保持进程的历史信息，设置还原点</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://lenhoon.github.io">Lenhoon</a>
            <p>原文链接：<a href="https://lenhoon.github.io/2017/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E6%AD%BB%E9%94%81/">https://lenhoon.github.io/2017/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E6%AD%BB%E9%94%81/</a>
            <p>发表日期：<a href="https://lenhoon.github.io/2017/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E6%AD%BB%E9%94%81/">八月 22日 2017, 4:55:25 下午</a>
            <p>更新日期：<a href="https://lenhoon.github.io/2017/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E6%AD%BB%E9%94%81/">August 22nd 2017, 7:21:22 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/Lenhoon.github.io/2017/08/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/" title= "操作系统知识点三处理机调度">
                    <div class="prevTitle">操作系统知识点三处理机调度</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="comment"></div>
    <script>
    new Valine({
        el: '#comment' ,
        notify:false, 
        verify:false, 
        appId: "EARSYI9Lva36aPVO3I5e5OIX-gzGzoHsz",
        appKey: "2uiaNKnLlgya5GhT016V1Y2h",
        placeholder: "期待您的评论",
        path:window.location.pathname, 
        avatar:'mm' 
    });
    </script>


    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:lenhooon@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/lenhoon" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/Lenhoon.github.io/assets/wechar_qr.jpeg" />
                </span>
            
        
    
        
    
        
    
        
    
        
            
                <a href="https://www.zhihu.com/people/Lenhoon" class="iconfont-archer zhihu" target="_blank" title=zhihu></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://juejin.im/user/563f42e100b09f85a30a6125" class="iconfont-archer juejin" target="_blank" title=juejin></a>
            
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="https://www.jianshu.com/u/c9ba268c653a" class="iconfont-archer others" target="_blank" title=others></a>
            
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">您是第<span id="busuanzi_value_site_pv"></span>位访客</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 4
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/Lenhoon.github.io/2017/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E6%AD%BB%E9%94%81/" >操作系统知识点四进程同步和死锁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span><a class="archive-post-title" href= "/Lenhoon.github.io/2017/08/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/" >操作系统知识点三处理机调度</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/17</span><a class="archive-post-title" href= "/Lenhoon.github.io/2017/08/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" >操作系统知识点二进程管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/Lenhoon.github.io/2017/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A6%82%E8%BF%B0/" >操作系统知识点-概述</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/Lenhoon.github.io/",
        author: "Lenhoon"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/Lenhoon.github.io/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/Lenhoon.github.io/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/Lenhoon.github.io/scripts/share.js" async></script>    
     
    </body>
</html>


